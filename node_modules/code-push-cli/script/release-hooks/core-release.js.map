{"version":3,"sources":["script/release-hooks/core-release.ts"],"names":[],"mappings":"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","file":"core-release.js","sourcesContent":["/// <reference path=\"../../../definitions/external/q/Q.d.ts\" />\n/// <reference path=\"../../../definitions/external/node/node.d.ts\" />\n/// <reference path=\"../../definitions/recursive-fs.d.ts\" />\n/// <reference path=\"../../definitions/slash.d.ts\" />\n/// <reference path=\"../definitions/slash.d.ts\" />\n/// <reference path=\"../../definitions/generated/code-push.d.ts\" />\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as recursiveFs from \"recursive-fs\";\nimport slash = require(\"slash\");\nimport * as Q from \"q\";\nimport Promise = Q.Promise;\nimport * as yazl from \"yazl\";\nvar progress = require(\"progress\");\n\nimport AccountManager = require(\"code-push\");\nimport {Package, PackageInfo} from \"code-push/script/types\";\nimport {CommonUtils} from \"../common-utils\";\nvar log = CommonUtils.log;\nimport * as cli from \"../../definitions/cli\";\nimport ReleaseFile = cli.ReleaseFile;\n\nvar coreReleaseHook: cli.ReleaseHook = (currentCommand: cli.IReleaseCommand, originalCommand: cli.IReleaseCommand, sdk: AccountManager): Promise<cli.IReleaseCommand> => {\n    return Q(<void>null)\n        .then(() => {\n            var releaseFiles: ReleaseFile[] = [];\n\n            if (!fs.lstatSync(currentCommand.package).isDirectory()) {\n                releaseFiles.push({\n                    sourceLocation: currentCommand.package,\n                    targetLocation: path.basename(currentCommand.package)  // Put the file in the root\n                });\n                return Q(releaseFiles);\n            }\n\n            var deferred = Q.defer<ReleaseFile[]>();\n            var directoryPath: string = currentCommand.package;\n            var baseDirectoryPath = path.join(directoryPath, \"..\");     // For legacy reasons, put the root directory in the zip\n\n            recursiveFs.readdirr(currentCommand.package, (error?: any, directories?: string[], files?: string[]): void => {\n                if (error) {\n                    deferred.reject(error);\n                    return;\n                }\n\n                files.forEach((filePath: string) => {\n                    var relativePath: string = path.relative(baseDirectoryPath, filePath);\n                    // yazl does not like backslash (\\) in the metadata path.\n                    relativePath = slash(relativePath);\n                    releaseFiles.push({\n                        sourceLocation: filePath,\n                        targetLocation: relativePath\n                    });\n                });\n\n                deferred.resolve(releaseFiles);\n            });\n\n            return deferred.promise;\n        })\n        .then((releaseFiles: ReleaseFile[]) => {\n            return Promise<string>((resolve: (file: string) => void, reject: (reason: Error) => void): void => {\n\n                var packagePath: string = path.join(process.cwd(), CommonUtils.generateRandomFilename(15) + \".zip\");\n                var zipFile = new yazl.ZipFile();\n                var writeStream: fs.WriteStream = fs.createWriteStream(packagePath);\n\n                zipFile.outputStream.pipe(writeStream)\n                    .on(\"error\", (error: Error): void => {\n                        reject(error);\n                    })\n                    .on(\"close\", (): void => {\n\n                        resolve(packagePath);\n                    });\n\n                releaseFiles.forEach((releaseFile: ReleaseFile) => {\n                    zipFile.addFile(releaseFile.sourceLocation, releaseFile.targetLocation);\n                });\n\n                zipFile.end();\n            });\n\n        })\n        .then((packagePath: string): Promise<cli.IReleaseCommand> => {\n            var lastTotalProgress = 0;\n            var progressBar = new progress(\"Upload progress:[:bar] :percent :etas\", {\n                complete: \"=\",\n                incomplete: \" \",\n                width: 50,\n                total: 100\n            });\n\n            var uploadProgress = (currentProgress: number): void => {\n                progressBar.tick(currentProgress - lastTotalProgress);\n                lastTotalProgress = currentProgress;\n            };\n\n            var updateMetadata: PackageInfo = {\n                description: currentCommand.description,\n                isDisabled: currentCommand.disabled,\n                isMandatory: currentCommand.mandatory,\n                rollout: currentCommand.rollout\n            };\n\n            return sdk.isAuthenticated(true)\n                .then((isAuth: boolean): Promise<Package> => {\n                    return sdk.release(currentCommand.appName, currentCommand.deploymentName, packagePath, currentCommand.appStoreVersion, updateMetadata, uploadProgress);\n                })\n                .then((): void => {\n                    log(`Successfully released an update containing the \"${originalCommand.package}\" `\n                        + `${fs.lstatSync(originalCommand.package).isDirectory()  ? \"directory\" : \"file\"}`\n                        + ` to the \"${currentCommand.deploymentName}\" deployment of the \"${currentCommand.appName}\" app.`);\n\n                })\n                .then(() => currentCommand)\n                .finally(() => {\n                    fs.unlinkSync(packagePath);\n                });\n        });\n}\n\nexport = coreReleaseHook;"],"sourceRoot":"../../.."}