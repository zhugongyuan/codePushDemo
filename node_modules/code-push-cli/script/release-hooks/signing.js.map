{"version":3,"sources":["script/release-hooks/signing.ts"],"names":[],"mappings":"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","file":"signing.js","sourcesContent":["import * as cli from \"../../definitions/cli\";\nimport * as crypto from \"crypto\";\nimport * as fs from \"fs\";\nimport * as hashUtils from \"../hash-utils\";\nimport * as jwt from \"jsonwebtoken\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport * as q from \"q\";\nvar rimraf = require(\"rimraf\");\nimport AccountManager = require(\"code-push\");\n\nvar CURRENT_CLAIM_VERSION: string = \"1.0.0\";\nvar METADATA_FILE_NAME: string = \".codepushrelease\";\n\ninterface CodeSigningClaims {\n    claimVersion: string;\n    contentHash: string;\n}\n\nconst deletePreviousSignatureIfExists = (package: string): q.Promise<any> => {\n    let signatureFilePath: string = path.join(package, METADATA_FILE_NAME);\n    let prevSignatureExists: boolean = true;\n    try {\n        fs.accessSync(signatureFilePath, fs.R_OK);\n    } catch (err) {\n        if (err.code === \"ENOENT\") {\n            prevSignatureExists = false;\n        } else {\n            return q.reject(new Error(\n                `Could not delete previous release signature at ${signatureFilePath}.\n                Please, check your access rights.`)\n            );\n        }\n    }\n\n    if (prevSignatureExists) {\n        console.log(`Deleting previous release signature at ${signatureFilePath}`);\n        rimraf.sync(signatureFilePath);\n    }\n\n    return q.resolve(<void>null);\n}\n\nvar sign: cli.ReleaseHook = (currentCommand: cli.IReleaseCommand, originalCommand: cli.IReleaseCommand, sdk: AccountManager): q.Promise<cli.IReleaseCommand> => {\n\n    if (!currentCommand.privateKeyPath) {\n        if (fs.lstatSync(currentCommand.package).isDirectory()) {\n            // If new update wasn't signed, but signature file for some reason still appears in the package directory - delete it\n            return deletePreviousSignatureIfExists(currentCommand.package).then(() => {\n                return q.resolve<cli.IReleaseCommand>(currentCommand); \n            });\n        } else {\n            return q.resolve<cli.IReleaseCommand>(currentCommand); \n        }   \n    }\n\n    let privateKey: Buffer;\n    let signatureFilePath: string;\n\n    return q(<void>null)\n        .then(() => {\n            signatureFilePath = path.join(currentCommand.package, METADATA_FILE_NAME);\n            try {\n                privateKey = fs.readFileSync(currentCommand.privateKeyPath);\n            } catch (err) {\n                return q.reject(new Error(`The path specified for the signing key (\"${currentCommand.privateKeyPath}\") was not valid`));\n            }\n\n            if (!fs.lstatSync(currentCommand.package).isDirectory()) {\n                // If releasing a single file, copy the file to a temporary 'CodePush' directory in which to publish the release\n                var outputFolderPath: string = path.join(os.tmpdir(), \"CodePush\");\n                rimraf.sync(outputFolderPath);\n                fs.mkdirSync(outputFolderPath);\n\n                var outputFilePath: string = path.join(outputFolderPath, path.basename(currentCommand.package));\n                fs.writeFileSync(outputFilePath, fs.readFileSync(currentCommand.package));\n\n                currentCommand.package = outputFolderPath;\n            }\n\n            return deletePreviousSignatureIfExists(currentCommand.package);    \n        })\n        .then(() => {\n            return hashUtils.generatePackageHashFromDirectory(currentCommand.package, path.join(currentCommand.package, \"..\"));\n        })\n        .then((hash: string) => {\n            var claims: CodeSigningClaims = {\n                claimVersion: CURRENT_CLAIM_VERSION,\n                contentHash: hash\n            };\n\n            return q.nfcall<string>(jwt.sign, claims, privateKey, { algorithm: \"RS256\" })\n                .catch((err: Error) => {\n                    return q.reject<string>(new Error(\"The specified signing key file was not valid\"));\n                });\n        })\n        .then((signedJwt: string) => {\n            var deferred = q.defer<void>();\n\n            fs.writeFile(signatureFilePath, signedJwt, (err: Error) => {\n                if (err) {\n                    deferred.reject(err);\n                } else {\n                    console.log(`Generated a release signature and wrote it to ${signatureFilePath}`);\n                    deferred.resolve(<void>null);\n                }\n            });\n\n            return deferred.promise;\n        })\n        .then(() => { return currentCommand; })\n        .catch((err: Error) => {\n            err.message = `Could not sign package: ${err.message}`;\n            return q.reject<cli.IReleaseCommand>(err);\n    });\n}\n\nexport = sign;"],"sourceRoot":"../../.."}