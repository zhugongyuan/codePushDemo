{"version":3,"sources":["script/hash-utils.ts"],"names":["generatePackageHashFromDirectory","generatePackageManifestFromZip","generatePackageManifestFromDirectory","hashFile","hashStream","PackageManifest","PackageManifest.constructor","PackageManifest.toMap","PackageManifest.computePackageHash","PackageManifest.serialize","PackageManifest.deserialize","PackageManifest.normalizePath","PackageManifest.isIgnored","startsWith","endsWith"],"mappings":"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","file":"hash-utils.js","sourcesContent":["/**\n * NOTE!!! This utility file is duplicated for use by the CodePush service (for server-driven hashing/\n * integrity checks) and Management SDK (for end-to-end code signing), please keep them in sync.\n */\n\nimport * as crypto from \"crypto\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as q from \"q\";\nimport * as stream from \"stream\";\n\n// Do not throw an exception if either of these modules are missing, as they may not be needed by the\n// consumer of this file.\n// - recursiveFs: Only required for hashing of directories\n// - yauzl: Only required for in-memory hashing of zip files\ntry { var recursiveFs = require(\"recursive-fs\"); } catch (e) {}\ntry { var yauzl = require(\"yauzl\"); } catch (e) {}\n\nimport Promise = q.Promise;\nconst HASH_ALGORITHM = \"sha256\";\n\nexport function generatePackageHashFromDirectory(directoryPath: string, basePath: string): Promise<string> {\n    if (!fs.lstatSync(directoryPath).isDirectory()) {\n        throw new Error(\"Not a directory. Please either create a directory, or use hashFile().\");\n    }\n\n    return generatePackageManifestFromDirectory(directoryPath, basePath)\n        .then((manifest: PackageManifest) => {\n            return manifest.computePackageHash()\n        });\n}\n\nexport function generatePackageManifestFromZip(filePath: string): Promise<PackageManifest> {\n    var deferred: q.Deferred<PackageManifest> = q.defer<PackageManifest>();\n    var reject = (error: Error) => {\n        if (deferred.promise.isPending()) {\n            deferred.reject(error);\n        }\n    }\n\n    var resolve = (manifest: PackageManifest) => {\n        if (deferred.promise.isPending()) {\n            deferred.resolve(manifest);\n        }\n    }\n\n    var zipFile: any;\n\n    yauzl.open(filePath, { lazyEntries: true }, (error?: any, openedZipFile?: any): void => {\n        if (error) {\n            // This is the first time we try to read the package as a .zip file;\n            // however, it may not be a .zip file.  Handle this gracefully.\n            resolve(null);\n            return;\n        }\n\n        zipFile = openedZipFile;\n        var fileHashesMap = new Map<string, string>();\n        var hashFilePromises: q.Promise<void>[] = [];\n\n        // Read each entry in the archive sequentially and generate a hash for it.\n        zipFile.readEntry();\n        zipFile\n            .on(\"error\", (error: any): void => {\n                reject(error);\n            })\n            .on(\"entry\", (entry: any): void => {\n                var fileName: string = PackageManifest.normalizePath(entry.fileName);\n                if (PackageManifest.isIgnored(fileName)) {\n                    zipFile.readEntry();\n                    return;\n                }\n\n                zipFile.openReadStream(entry, (error?: any, readStream?: stream.Readable): void => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    hashFilePromises.push(\n                        hashStream(readStream)\n                            .then((hash: string) => {\n                                fileHashesMap.set(fileName, hash);\n                                zipFile.readEntry();\n                            }, reject)\n                    );\n                });\n            })\n            .on(\"end\", (): void => {\n                q.all(hashFilePromises).then(\n                    () => resolve(new PackageManifest(fileHashesMap)),\n                    reject\n                );\n            });\n    });\n\n    return deferred.promise\n        .finally(() => zipFile && zipFile.close());\n}\n\nexport function generatePackageManifestFromDirectory(directoryPath: string, basePath: string): Promise<PackageManifest> {\n    var deferred: q.Deferred<PackageManifest> = q.defer<PackageManifest>();\n    var fileHashesMap = new Map<string, string>();\n\n    recursiveFs.readdirr(directoryPath, (error?: any, directories?: string[], files?: string[]): void => {\n        if (error) {\n            deferred.reject(error);\n            return;\n        }\n\n        if (!files || files.length === 0) {\n            deferred.reject(\"Error: Can't sign the release because no files were found.\");\n            return;\n        }\n\n        // Hash the files sequentially, because streaming them in parallel is not necessarily faster\n        var generateManifestPromise: Promise<void> = files.reduce((soFar: Promise<void>, filePath: string) => {\n            return soFar\n                .then(() => {\n                    var relativePath: string = PackageManifest.normalizePath(path.relative(basePath, filePath));\n                    if (!PackageManifest.isIgnored(relativePath)) {\n                        return hashFile(filePath)\n                            .then((hash: string) => {\n                                fileHashesMap.set(relativePath, hash);\n                            });\n                    }\n                });\n        }, q(<void>null));\n\n        generateManifestPromise\n            .then(() => {\n                deferred.resolve(new PackageManifest(fileHashesMap));\n            }, deferred.reject)\n            .done();\n    });\n\n    return deferred.promise;\n}\n\nexport function hashFile(filePath: string): Promise<string> {\n    var readStream: fs.ReadStream = fs.createReadStream(filePath);\n    return hashStream(readStream);\n}\n\nexport function hashStream(readStream: stream.Readable): Promise<string> {\n    var hashStream = <stream.Transform><any>crypto.createHash(HASH_ALGORITHM);\n    var deferred: q.Deferred<string> = q.defer<string>();\n\n    readStream\n        .on(\"error\", (error: any): void => {\n            if (deferred.promise.isPending()) {\n                hashStream.end();\n                deferred.reject(error);\n            }\n        })\n        .on(\"end\", (): void => {\n            if (deferred.promise.isPending()) {\n                hashStream.end();\n\n                var buffer = <Buffer>hashStream.read();\n                var hash: string = buffer.toString(\"hex\");\n\n                deferred.resolve(hash);\n            }\n        });\n\n    readStream.pipe(hashStream);\n\n    return deferred.promise;\n}\n\nexport class PackageManifest {\n    private _map: Map<string, string>;\n\n    public constructor(map?: Map<string, string>) {\n        if (!map) {\n            map = new Map<string, string>();\n        }\n        this._map = map;\n    }\n\n    public toMap(): Map<string, string> {\n        return this._map;\n    }\n\n    public computePackageHash(): Promise<string> {\n        var entries: string[] = [];\n        this._map.forEach((hash: string, name: string): void => {\n            entries.push(name + \":\" + hash);\n        });\n\n        // Make sure this list is alphabetically ordered so that other clients\n        // can also compute this hash easily given the update contents.\n        entries = entries.sort();\n\n        return q(\n            crypto.createHash(HASH_ALGORITHM)\n                .update(JSON.stringify(entries))\n                .digest(\"hex\")\n        );\n    }\n\n    public serialize(): string {\n        var obj: any = {};\n\n        this._map.forEach(function(value, key) {\n            obj[key] = value;\n        });\n\n        return JSON.stringify(obj);\n    }\n\n    public static deserialize(serializedContents: string): PackageManifest {\n        try {\n            var obj: any = JSON.parse(serializedContents);\n            var map = new Map<string, string>();\n\n            for (var key of Object.keys(obj)) {\n                map.set(key, obj[key]);\n            }\n\n            return new PackageManifest(map);\n        } catch (e) {\n        }\n    }\n\n    public static normalizePath(filePath: string): string {\n        //replace all backslashes coming from cli running on windows machines by slashes\n        return filePath.replace(/\\\\/g, \"/\");\n    }\n\n    public static isIgnored(relativeFilePath: string): boolean {\n        const __MACOSX = \"__MACOSX/\";\n        const DS_STORE = \".DS_Store\";\n        const CODEPUSH_METADATA = \".codepushrelease\";\n        return startsWith(relativeFilePath, __MACOSX)\n            || relativeFilePath === DS_STORE\n            || endsWith(relativeFilePath, \"/\" + DS_STORE)\n            || relativeFilePath === CODEPUSH_METADATA\n            || endsWith(relativeFilePath, \"/\" + CODEPUSH_METADATA);\n    }\n}\n\nfunction startsWith(str: string, prefix: string): boolean {\n    return str && str.substring(0, prefix.length) === prefix;\n}\n\nfunction endsWith(str: string, suffix: string): boolean {\n    return str && str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n"],"sourceRoot":"../.."}